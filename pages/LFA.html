<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="shortcut icon" href="../favicons/synthsun.ico" type="image/x-icon">
	<title>Resumo LFA</title>
	<style>
		:root {
			--maincor: #023047;
			--analogo: #219ebc;
			--analogo2: #8ecae6;
			--contraste: #ffb703;
			--contraste2: #fb8500;

		}

		* {
			margin: 0px;
			padding: 0px;
		}

		body {
			font-family: 'Lucida Sans', 'Lucida Sans Regular', 'Lucida Grande', 'Lucida Sans Unicode', Geneva, Verdana, sans-serif;
			/*background-color: var(--analogo2);*/
			background-image: linear-gradient(135deg, var(--analogo2), var(--analogo) ,var(--maincor));
		}

		header {
			border: 2px solid black;
			width: fit-content;
			margin: 30px auto 30px auto;
			padding: 20px 50px;
			text-shadow: 1px 1px 2px black;
			font-family: Haettenschweiler, 'Arial Narrow Bold', sans-serif;
			font-size: 1.5em;
			box-shadow: 2px 0px 10px rgba(0, 0, 0, 0.253);
		}

		ul#navul {
			list-style: none;
			line-height: 1em;
		}

		div.dropdownbutton {
			position: fixed;
			float: left;
			left: 0px;
			top: 0px;
			max-width: fit-content;
			padding: 5px 15px;
			border: 1px solid black;
		}

		div.dropdowncontent {
			display: none;
			position: absolute;
			left: 0%;
			top: calc(100% + 1px);
			padding: 20px;
			min-width: 350px;
			overflow: auto;
			outline: 1px solid black;
		}

		div.dropdownbutton:hover .dropdowncontent {
			display: block;
		}

		div.topic {
			margin: 20px auto;
			border: 1px solid black;
			background-color: white;
			min-width: 300px;
			max-width: 900px;
			padding: 0px 10px 20px 10px;
			width: 83%;
			box-shadow: 2px 0px 10px rgba(0, 0, 0, 0.253);
			border-radius: 0px 0px 5px 5px;
		}

		.topic h1 {
			margin: 15px;
			color: var(--contraste2);
		}

		.att {
			margin: 2em;
			padding: 5px;
			text-align: center;
			box-shadow: 2px 1px 5px rgba(0, 0, 0, 0.253);
			border: 1px solid black;
			border-radius: 20px;
			background-color: var(--maincor);
			color: white;
		}

		.att h3 {
			padding: 0px;
		}

		a {
			text-decoration: none;
			text-transform: uppercase;
			color: var(--contraste);
			font-weight: bolder;
		}

		a:hover {
			color: var(--contraste2);
		}

		.topic a {
			display: block;
			line-height: 2em;
			text-indent: 2em;
		}

		h1 {
			text-align: center;
		}

		h2 {
			text-indent: 2em;
			padding: 15px;
		}

		.topic p {
			padding: 15px;
			text-indent: 1em;
		}

		span.destaque {
			color: var(--analogo);
			font-weight: bold;
		}

		.topic ul {
			list-style: inside;
			line-height: 2em;
			padding: 20px;
			text-indent: 1.3em;
		}

		.topic ol {
			list-style-type: decimal;
			list-style-position: inside;
			padding-left: 30px;
		}

		ul.inside {
			padding: 0px 25px;
		}

		table {
			border-collapse: collapse;
			margin: auto;
		}

		td {
			border: 1px solid black;
			padding: 3px;
		}
	</style>
</head>
<body>
	<!--SYMBOLS QUICK REFERENCE
	gamma:        Γ
	little gamma: γ
	:             Σ
	omega:        ω
	alpha:        α
	beta:         β
	:             δ
	empty:        ∅
	pertence      ∈
	:             ε
	turnsytle     ⊢ (ou catraca)
	small lambda: λ
	-->
	<h1>Pontos Chave de Linguagens Formais e Automatas</h1>

	<div class="dropdownbutton">
		<p>Índice</p>
		<div class="dropdowncontent">
			<ul>

			</ul>
		</div>
	</div>

	<div class="topic">
		<h1>To-do</h1>
		<ul>
			<li>trocar (gamma) por um gamma com chapeu</li>
			<li>colocar o somatorio apropriadoe em (somatorio)</li>
		</ul>
	</div>

	<div class="topic">
		<h1 id="alfabeto">Alfabetos e cadeias</h1>
		<p>Um <span class="destaque">alfabeto</span> é um conjunto finito de elementos chamados <span class="destaque">símbolos</span> geralmente representados por letras gregas maíusculas. <br>
		Exemplos: Σ = {0,1}, Σ<sub>1</sub> = {a,b, ... , z} , Σ<sub>2</sub> = {a,b}, Γ = {#. a1. bd}</p>
		
		<p>Dado um alfabeto Σ, uma <span class="destaque">cadeia</span> (sobre Σ) é uma sequência x<sub>1</sub>x<sub>2</sub>...x<sub>n</sub>, onde x<sub>i</sub> ∈ Σ para cada 1 <= i <= n, ou seja, é uma sequência finita de símbolos. <br>
		Geralmente, representadas por letras gregas minúsculas. <br>
		Outros termos: <span class="destaque">strings</span> ou <span class="destaque">palavras</span>.</p>

		<p>O <span class="destaque">comprimento</span> de uma cadeia ω é a quantidade de posições na sequência e é denotado por |ω|. <br>
		<h3>Exemplos:</h3> 
			<ul>
				<li>ω = 011011 é a cadeia sobre Σ = {0,1} e |ω| = 6</li>
				<li>α=carla é a cadeia sobre Σ<sub>1</sub> = {a,b, ... ,z} e |α| = 5</li>
				<li>β = bd#a1bd é a cadeia sobre Γ = {#, a1, bd} e |β| = 4</li>
			</ul>
		</p>

		<p>Se x ∈ Σ e ω é cadeia sobre Σ, denotamos por |ω|<sub>x</sub> a quantidade de vezes que o símbolo x aparece em ω.</p>
		<h3>Exemplos</h3>
		<ul>
			<li>|α|<sub>a</sub> = 2</li>
			<li>|ω|<sub>1</sub> = 4</li>
		</ul>
	</div>

	<div class="topic">
		<h1 id="cadeiaconc">Concatenação de cadeias</h1>
		<p>A <span class="destaque">concatenação</span> de uma cadeia α = α<sub>1</sub>α<sub>2</sub>...α<sub>n</sub> com uma cadeia β = β<sub>1</sub>β<sub>2</sub>...β<sub>m</sub> é a cadeia αβ = α<sub>1</sub>α<sub>2</sub>...α<sub>n</sub>β<sub>1</sub>β<sub>2</sub>...β<sub>m</sub> <br>
		Denotamos por α<sup>k</sup> a concatenação de α com ela mesma k vezes.</p>

		<h2>Cadeia importantes</h2>
		<p>O <span class="destaque">reverso</span> da cadeia ω = ω<sub>1</sub>ω<sub>2</sub>...ω<sub>n</sub> é a cadeia ω<sup>R</sup> = ω<sub>n</sub>w<sub>n-1</sub>...ω<sub>1</sub>.</p>

		<p>A <span class="destaque">cadeia vazia</span>, denotada por ε, é a cadeia de comprimento 0. <br>
		Obs: para qualquer cadeia ω sobre Σ, ωε = εω = ω</p>
	</div>

	<div class="topic">
		<h1 id="subcadeia">Subcadeias</h1>
		<p>Uma cadeia β é <span class="destaque">subcadeia</span> de outra cadeia ω se existem cadeia α e γ tais que ω = αβγ</p>
	</div>

	<div class="topic">
		<h1 id="alfabetopot">Potência de alfabeto</h1>
		<p>Dados um alfabeto Σ, denotamos por Σ<sup>k</sup> o conjunto de todas as cadeias de comprimento k sobre Σ. <br>
		Obs: |Σ<sup>k</sup>| = |Σ|<sup>k</sup></p>
	</div>

	<div class="topic">
		<h1 id="fechokleene">Fecho de Kleene e fecho positivo de alfabetos</h1>
		<p>fecho de Kleene de Σ, denotado por Σ*, é o conjunto de todas as cadeias sobre Σ, isto é, <span style="display: block;">Σ* = Σ<sup>0</sup> U Σ<sup>1</sup> Σ<sup>2</sup> U ... = (somatorio)</span></p>
		<p>O <span class="destaque">fecho positivo</span> de Σ, denotado por Σ<sup>+</sup>, é conjunto de toas as cadeias não vazias sobre Σ</p>

		<p><span class="def">Obervação:</span> agora, ao invés de escrever "ω é uma cadeia sobre o alfabeto Σ", basta escrever "ω ∈ Σ*"</p>
	</div>

	<div class="topic">
		<h1 id="linguagem">Linguagem</h1>
		<p>Uma <span class="destaque">linguagem</span> sobre um alfabeto Σ é um subconjunto de Σ*. Geralmente representadas por letras maiúsculas. Assim, "L é uma linguagem sobre Σ* equivale a "L ⊆ Σ*"</p>

	</div>

	<div class="topic">
		<h1 id="afd">Automato Finito Determinístico</h1>
		<p><span class="def">Definição:</span> Um autômato finito determinístico (AFD) é uma 5-upla (Q, Σ, δ, q<sub>0</sub>, F) em que:</p>
		<ul>
			<li>Q é um conjuto finito de <span class="destaque">estados</span></li>
			<li>Σ é um alfabeto</li>
			<li>Q x Σ &#8594; Q é uma <span class="destaque">função de transição</span></li>
			<li>q<sub>0</sub> é o <span class="destaque">estado inicial</span></li>
			<li>F ⊆ Q é o conjunto de <span class="destaque">estados finais</span></li>
		</ul>
	</div>

	<div class="topic">
		<h1 id="tranfuncex">Função de transição estendida</h1>
		<p><span class="def">Definição:</span> Seja M = (Q, Σ, δ, q<sub>0</sub>, F) um AFD. A <span class="destaque"> Função de transição estendida</span> de M é a função δ^: Q x Σ* &#8594; Q definida da seguinte forma: para q ∈ Q e ω ∈ Σ*,</p>
		<table>
			<tr>
				<td rowspan="2">δ^(q,ω) =</td>
				<td>q</td>
				<td>se ω = ε</td>
			</tr>
			<tr>
				<td>δ(gamma(q,α), x)</td>
				<td>se ω = αx, com x ∈ Σ e α ∈ Σ*</td>
			</tr>
		</table>
		<p>Ou seja, δ^(q,ω) é o estado ativo em M após computar toda uma cadeia ω a partir do estado q.</p>
	</div>

	<div class="topic">
		<h1 id="afdaceite">Aceite de um AFD</h1>
		<p><span class="def">Definição:</span> Seja M = (Q, Σ, δ, q<sub>0</sub>, F) um AFD e seja ω ∈ Σ*. Dizemos que <span class="destaque">M aceita ω</span> se gamma(q<sub>0</sub>,ω) ∈ F. Caso contrário, <span class="destaque">M rejeita ω</span></p>	
		
		<p><span class="def">Definição alternativa:</span> Seja M = (Q, Σ, δ, q<sub>0</sub>, F) um AFD e seja ω = ω<sub>1</sub>ω<sub>2</sub>...ω<sub>n</sub> uma cadeia sobre Σ (ω ∈ Σ*). <br>
		Dizemos que <span class="destaque">M aceita ω</span> se existe uma sequência de estados (r<sub>0</sub>,r<sub>1</sub>,...,r<sub>n</sub>) tal que </p>
		<ul>
			<li>r<sub>0</sub> = q<sub>0</sub></li>
			<li>r<sub>i + 1</sub> = δ(r<sub>i</sub>, ω<sub>i + 1</sub>) para qualquer  i = 0, ... , n- 1</li>
			<li>r<sub>n</sub> ∈ F</li>
		</ul>
	</div>

	<div class="topic">
		<h1 id="afdlinguagem">A linguagem de um AFD</h1>
		<p><span class="def">Definição:</span> Seja M = (Q, Σ, δ, q<sub>0</sub>, F) um AFD. Dizemos que X = {ω ∈ Σ* : M aceita ω} é <span class="destaque">a linguagem reconhecida por M</span>, ou simplesmente <span class="destaque">a linguagem de M</span>. <br>
		Também dizemos que <span class="destaque">M reconhece X</span>. <br>
		Denotamos tal linguagem por L(M).</p>

		<div class="att">
			<h1><u>Importante</u></h1>
			<p>
				um AFD <span class="destaque">aceita</span> cadeias (0 ou mais). <br>
				Ele <span class="destaque">reconhece</span> uma única linguagem.
			</p>
		</div>
	</div>

	<div class="topic">
		<h1 id="afn">Automato Finito não Determinístico</h1>
		<p><span class="def">Definição:</span> um <span class="destaque">automato finito não determinístico (AFN)</span> é uma 5-upla (Q, Σ, δ, q<sub>0</sub>, F) em que:</p>
		<ul>
			<li>Q é um conjuto finito de <span class="destaque">estados</span></li>
			<li>Σ é um alfabeto</li>
			<li>δ: Q x (Σ U {ε}) &#8594; P(Q) é uma <span class="destaque">função de transição</span></li>
			<li>q<sub>0</sub> é o <span class="destaque">estado inicial</span></li>
			<li>F ⊆ Q é o conjunto de <span class="destaque">estados finais</span></li>
		</ul>
	</div>

	<div class="topic">
		<h1 id="fechamento">ε - fechamento</h1>
		<p><span class="def">Definição:</span> Seja N = (Q, Σ, δ, q<sub>0</sub>, F) um AFN. Para q ∈ Q, o <span class="destaque">ε-fechamento de q</span>, denotado E(q), é o conjunto de estados tal que :</p>
		<ul>
			<li>q ∈ E(q)</li>
			<li>se r ∈ E(q) e s ∈ δ(r,ε), então s ∈ E(q).</li>
		</ul>
		<p>Ou seja: E(q) é o conjunto de estados alcançáveis a partir de q seguindo 0 ou mais transições com rótulo ε.</p>
		<p>E(q) é o conjunto de estados que ficam ativos no instante que q fica ativo.</p>
	</div>

	<div class="topic">
		<h1 id="functransexafn">Função de transição estendida</h1>
		<p><span class="def">Definição:</span> Seja N = (Q, Σ, δ, q<sub>0</sub>, F) um AFN. A <span class="destaque">função de transição estendida</span> de N é a função δ^: Q x Σ* &#8594; P(Q) definida de seguinte forma: para q ∈ Q e ω ∈ Σ*,</p>
		<table>
			<tr>
				<td rowspan="2">δ^(q,ω) =</td>
				<td>E(q)</td>
				<td>se ω = ε</td>
			</tr>
			<tr>
				<td>E(δ(δ^(q,α), x))</td>
				<td>se ω = αx, com x ∈ Σ e α ∈ Σ*</td>
			</tr>
		</table>
		<p>Ou seja, δ^(q,ω) é o conjunto de estados ativos em N após computar toda uma cadeia ω a partir do estado q.</p>
	</div>

	<div class="topic">
		<h1 id="afnaceite">Aceite em um AFN</h1>
		<p><span class="def">Definição:</span> Seja N = (Q, Σ, δ, q<sub>0</sub>, F) um AFN e seja ω ∈ Σ*. Dizemos que <span class="destaque">N aceita ω se δ^(q<sub>0</sub>,ω) ∩ F ≠ ∅. Caso contrário, <span class="destaque">N rejeita ω</span></span></p>
	</div>

	<div class="topic">
		<h1 id="afnaceitealt">Aceite em um AFN - Definição Alternativa</h1>
		<p><span class="def">Definição:</span> Seja N = (Q, Σ, δ, q<sub>0</sub>, F) um AFN e seja ω = ω<sub>1</sub>ω<sub>2</sub>...ω<sub>n</sub> uma cadeia sobre Σ (ω ∈ Σ*)<br>
		Dizemos que <span class="destaque">N aceita ω</span> se podemos escrever ω = x<sub>1</sub>x<sub>2</sub>...x<sub>n</sub>, com cada x<sub>i</sub> ∈ Σ U {ε} e existe uma sequência de estados (r<sub>0</sub>r<sub>1</sub>...r<sub>n</sub> tal que</p>
		<ul>
			<li>r<sub>0</sub> = q<sub>0</sub></li>
			<li>r<sub>i + 1</sub> ∈ δ(r<sub>i</sub>,α<sub>i + 1</sub>       para qualquer i = 0,...,m-1</li>
			<li>r<sub>m</sub> ∈ F</li>
		</ul>
	</div>

	<div class="topic">
		<h1 id="afnlinguagem">A linguagem de um AFN</h1>
		<p><span class="def">Definição:</span> Seja N = (Q, Σ, δ, q<sub>0</sub>, F) um AFN. Dizemos que X = {ω ∈ Σ* : N aceita ω} é <span class="destaque">a linguagem reconhecida por N</span>, ou simplesmente <span class="destaque">a linguagem de N</span>. <br>
		Também dizemos que <span class="destaque">N reconhece X</span>. <br>
		Denotamos tal linguagem por L(N).</p>
	</div>

	<div class="topic">
		<h1 id="regex">Expressões Regulares</h1>
		<p><span class="def">Definição:</span> R é uma <span class="destaque">expressão regular</span> sobre um alfabeto Σ que descreve a linguagem L(R) se</p>
		<ol>
			<li>R = <strong>x</strong> para algum x ∈ Σ. Nesse caso, L(R) = {x}</li>
			<li>R = <strong>ε</strong>. Nesse caso, L(R) = {ε}</li>
			<li>R = <strong>∅</strong>. Nesse caso, L(R) = ∅</li>
			<p>E sendo R<sub>1</sub> e R<sub>2</sub> duas expressões regulares,</p>
			<li>R = R<sub>1</sub> U R<sub>2</sub>. Nesse caso, L(R) = L(R<sub>1</sub>) U L(R<sub>2</sub>)</li>
			<li>R = R<sub>1</sub>R<sub>2</sub>. Nesse caso, L(R) = L(R<sub>1</sub>)L(R<sub>2</sub>)</li>
			<li>R = R<sub>1</sub>*. Nesse caso, L(R) = L(R<sub>1</sub>)*</li>
		</ol>
		<p>É possível agrupar operadores usando parênteses (se R = (R'), então L(R) = L(R'))</p>
		<p><span class="def">Lema:</span> A linguagem descrita por uma expressão regluar é regular</p>
	</div>

	<div class="topic">
		<h1 id="gramatica">Gramaticas</h1>
		<p>São dispositivos geradores que se aproveitam de recursão</p>
		<p>Os símbolos do alfabeto das cadeias da linguagem são chamados <span class="destaque">terminais</span></p>
		<p>Existe um outro alfabeto, cujos símbolos são chamados de <span class="destaque">variáveis</span></p>
		<p>Cada variável representa uma linguagem <ul><li>A <span class="destaque">variável inicial</span> representa a linguagem "principal"</li></ul></p>
		<p>Existe um conjunto finito de <span class="destaque">regras de substituição:</span> <ul><li>especificam combinações válidas de símbolos</li> <li>um regra <span class="destaque">α -> β</span> indica que α pode ser substituído por β sendo que α e β são cadeias de variáveis e terminais.</li></ul></p>
		<p>Geramos cadeias de terminais por meio de uma sequência de substituições a partir da variável inicial</p>
		<p>Existem vários tipos de gramáticas:</p>
		<ul>
			<li>Lineares</li>
			<li>Livres de contexto</li>
			<li>Sensíveis ao contexto</li>
			<li>Irrestritas</li>
		</ul>
	</div>

	<div class="topic">
		<h1 id="glc">Gramáticas livres de Contexto</h1>

		<p><span class="def">Definição:</span> Uma <span class="destaque">gramática livre de contexto (GLC)</span> é uma 4-upla (V, Σ, R, S) onde</p>
		<ul>
			<li>V é um conjunto finito de <span class="destaque">variáveis</span></li>
			<li>Σ é um conjunto finito de <span class="destaque">terminais</span>, com V ∩ Σ = ∅</li>
			<li>R é um conjunto finito de <span class="destaque">regras de substituição</span> na forma X -> α, onde X ∈ V e α ∈ (Σ U V)*</li>
			<li>S é a <span class="destaque">variável inicial</span></li>
		</ul>

		<h2 id="subrules">Usando as regras de substituição</h2>
		<p><span class="def">Definição:</span> Se α, β e ω são cadeias de variáveis e terminais e A -> ω é uma regra de substituição, então dizemos que "αAβ <span class="destaque">origina</span> αωβ" e escrevemos <span class="destaque">αAβ -> αωβ</span></p>
	</div>

	<div class="topic">
		<h1 id="derivacoes">Derivações</h1>
		<p><span class="def">Definição:</span> Sejam α e β cadeuas de variáveis e terminais. Dizemos que <span class="destaque">α deriva β</span>, denotado <span class="destaque">α *=>β</span>, se</p>
		<ol>
			<li>α=β, ou</li>
			<li>existem cadeias de var. e term. γ<sub>1</sub>,γ<sub>2</sub>,...,γ<sub>k</sub>, k >= 0, tais que α -> γ<sub>1</sub> -> γ<sub>2</sub> -> ... -> γ<sub>k</sub> -> β</li>
		</ol>
	</div>

	<div class="topic">
		<h1 id="parsetrees">Árvores sintáticas (Parse trees)</h1>
		<p>Uma derivação pode ser representada por uma <span class="destaque">árvore sintática</span></p>
		<ul>
			<li>Cada nó interno é uma variável</li>
			<li>Cada folha é uma variável, um terminal ou ε</li>
			<li>Se um nó interno tem rótulo A e seus filhos são, da esquerda para a direita, X<sub>1</sub>, X<sub>2</sub>, ..., X<sub>k</sub>, então A -> X<sub>1</sub>X<sub>2</sub>...X<sub>k</sub> é uma regra de produção da gramática</li>
		</ul>
	</div>

	<div class="topic">
		<h1 id="linggram">Linguagem de uma gramática</h1>
		<p><span class="def">Definição:</span> Seja G uma gramática cuja variável inicial é S e o conjunto de terminais é Σ. <br>
		A <span class="destaque">linguagem de G</span>, denotada por L(G) é o conjunto {ω ∈ Σ*: S *+> ω}</p>
	</div>

	<div class="topic">
		<h1 id="llc">Linguagens Livres de Contexto</h1>
		<p><span class="def">Definição:</span> Uma linguagem é livre de contexto se alguma gramática livre de contexto a gera</p>

		<p><span class="def">Teorema:</span> Toda linguagem regular é livre de contexto</p>
	</div>

	<div class="topic">
		<h1 id="ap">Automatos com Pilha</h1>
		<p><span class="def">Definição:</span>Um <span class="destauqe">autômato com pilha (AP)</span>é uma 6-upla (Q, Σ, Γ, δ, q<sub>0</sub>, F) em que</p>
		<ul>
			<li>Q é um conjunto finito de <span class="destaque">estados</span></li>
			<li>Σ é o <span class="destaque">alfabeto de entrada</span></li>
			<li>Γ é o <span class="destaque">alfabeto da pilha</span></li>
			<li>δ : Q x (Σ U {ε}) x (Γ U {ε}) -> P(Q x (Γ U {ε})) é a <span class="destaque">função de transição</span></li>
			<li>q<sub>0</sub> é o <span class="destaque">estado inicial</span></li>
			<li>F ⊆ Q é o conjunto de <span class="destauqe">estados finais</span></li>
		</ul>
	</div>

	<div class="topic">
		<h1 id="di">Descrição Instantânea</h1>
		<p><span class="def">Definição:</span> A <span class="destaque">descrição instantânea</span> de um Ap P=(Q, Σ, Γ, δ, q<sub>0</sub>, F) é dada pela tripla <span class="destaque">(q, ω, γ)</span> em que</p>
		<ul>
			<li>q é um estado</li>
			<li>ω ∈ Σ* é a entrada restante</li>
			<li>γ ∈ Γ* é o conteúdo da pilha (com o topo à direita)</li>
		</ul>
	</div>

	<div class="topic">
		<h1 id="apaceite">Aceite e reconecimento em AP</h1>
		<p><span class="def">Definição:</span> Dado um AP P = (Q, Σ, Γ, δ, q<sub>0</sub>, F) e uma cadeia ω ∈ Σ*, dizemos que <span class="destaque">P aceita ω</span> se <br> (q<sub>0</sub>, ω, ε) ⊢* (q, ε, γ) <br>
		sendo q ∈ F e γ ∈ Γ*.</p>
		<p>A linguagem Z = {ω ∈ Σ*: P aceita ω} é a <span class="destaque">linguagem reconhecida por P</span> ou a <span class="destaque">linguagem de P</span>, e escrevemos L(P) = X.</p>

		<h2>Definição alternativa de aceite</h2>
		<p><span class="def">Definição:</span> Dado um AP P = (Q, Σ, Γ, δ, q<sub>0</sub>, F) e uma cadeia ω ∈ Σ*, dizemos que <span class="destaque">P aceita ω</span> se ω pode ser escrita como x<sub>1</sub>x<sub>2</sub>...x<sub>m</sub>, com cada x<sub>i</sub> ∈ Σ U {ε} e se existem sequências ( r<sub>0</sub>r<sub>1</sub>...r<sub>m</sub> de estados e  (γ<sub>0</sub>γ<sub>1</sub>...γ<sub>m</sub>) de cadeias γ<sub>i</sub> ∈ Γ* tais que</p>
		<ul>
			<li>r<sub>0</sub> = q<sub>0</sub></li>
			<li>r<sub>m</sub> ∈ F</li>
			<li>(r<sub>i+1</sub>, Y) ∈ δ(r<sub>i</sub>, x<sub>i+1</sub>, X) para qualquer 0 <= i < m, com γ<sub>i</sub> = Xλ e γ<sub>i+1</sub> = Yλ sendo λ ∈ Γ*</li>
		</ul>
	</div>

	<div class="topic">
		<h1 id="apglc">Ap e lingugens livres de contexto</h1>
		<p><span class="def">Teorema:</span> Uma linguagem é livre e contexto se e somente se algum autômato com pilha a reconhece.</p> 
	</div>

	<script>
		var topics = document.querySelectorAll('div.topic') //get all topic
		var indexul = document.querySelector('div.dropdowncontent').getElementsByTagName('ul')[0] //get the ul where the index will be

		for (i = 0; i < topics.length; i++) {
			var h1 = topics[i].getElementsByTagName('h1')[0]
			indexul.innerHTML += '<li><a href="#'+ h1.id + '">' + h1.innerText + '</a></li>\n'
			
			var h2array = topics[i].querySelectorAll('h2')
			if (h2array != null) {
				indexul.innerHTML += '<ul id="ul' + i + '"></ul>'
				var insideul = indexul.querySelector('ul#ul' + i)
				for (j = 0; j < h2array.length; j++) {
					insideul.innerHTML += '<li><a href="#'+ h2array[j].id + '">' + h2array[j].innerText + '</a></li>\n'
				}
			}
		}
	</script>
</body>
</html>